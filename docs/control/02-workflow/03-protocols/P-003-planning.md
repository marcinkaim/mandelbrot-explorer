<!--
  Mandelbrot Explorer
  Copyright (C) 2026 Marcin Kaim

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->

# PROTOCOL: P-003 - PLANNING

## 1. Philosophy: "Algorithmic Intent"

The **Planning** protocol is designed to eliminate "Probabilistic Coding" (guessing). Before any code is modified or any test is run, the Agent must declare a deterministic vector of change.

It applies the **Measure Twice, Cut Once** principle to software engineering. By forcing the Agent to serialize their cognitive process into discrete, atomic steps *before* execution, we achieve two goals:
1.  **Error Correction:** Logical fallacies are often caught during the articulation of the plan, preventing wasted compute cycles.
2.  **Audit Trail:** The Plan serves as a commitment contract against which the final Report is validated.

## 2. The Plan Structure

The official, executable template for this protocol is located at:
`docs/control/02-workflow/02-document-templates/template-action-plan.md`

**Applicability:** This protocol is used by the **Engineer**, **DevOps**, and **Tester** roles.

All Agents preparing to enter the **Execution Loop** MUST generate a response strictly adhering to this structure.

### 2.1. The Container
The Action Plan is a standalone Markdown document. Like the Action Report, it is a **New File Creation** event. Once created, a Plan is considered **Immutable**â€”if the plan changes significantly during execution, a new Plan file (incremented sequence) should be created to reflect the pivot.

### 2.2. Sections
* **Metadata Header:** Links the plan to a specific Task ID and establishes the starting state (Input Commit).
* **Strategy:** High-level approach and constraints (ADR compliance).
* **Execution Steps:** The core algorithm. A linear sequence of atomic actions.
* **Verification & Rollback:** Safety mechanisms to ensure system stability.

---

## 3. Rules of Engagement (The "Constraints")

To ensure the plan is actionable and machine-parsable, Agents must adhere to these rules:

### Rule 1: Deterministic Metadata & Naming
The Agent does NOT choose the filename arbitrarily. The Agent fills the **Metadata Header**. The System derives the filename from strict convention.

* **Sequence ID:** Must act as a logical clock (e.g., `PLAN-01`, `PLAN-02`).
* **Relates To:** Must cite the parent Task Definition (e.g., `TASK-3.1`).
* **Role:** Must match the active Persona.

*Derivation Logic (for reference):*
`[SEQUENCE_ID]-[ROLE_LOWERCASE].md`
*(e.g., `PLAN-01-engineer.md` located inside the specific Task's report directory)*

### Rule 2: Atomicity (The "One Step, One Commit" Ideal)
Steps in the "Execution Steps" section must be granular.
* **Bad:** "Implement the rendering engine." (Too abstract).
* **Good:** "Create `src/compute/cuda_engine.ads` spec file." (Concrete).
Ideally, each step corresponds to a unit of work that could be a single Git commit or a verifiable shell command.

### Rule 3: Constraint Checking
The "Strategy" section MUST explicitly reference relevant architectural constraints.
* If touching CUDA code, cite `ADR-0003`.
* If modifying public APIs, cite `ADR-0006`.
This proves the Agent has "loaded" the context before writing code.

### Rule 4: Metadata Exclusion
* **No License Headers:** Do NOT include copyright or license headers (e.g., GPL preambles) in the plan content. The plan is a transient project artifact, not source code for redistribution.

### Rule 5: Verifiability
Every Execution Step must have a `Verification` field.
* **Bad:** "Check if it works."
* **Good:** "Run `alr build` to confirm spec compliance." or "Verify `obj/main` binary exists."

## 4. Parser Logic (Reference Implementation Guide)

The tooling handling the `Action Plan` response operates as follows:

1. **Extract Content:** Capture the Markdown block generated by the Agent.
2. **Parse Metadata:** Read `Sequence ID` and `Relates To` (Task ID).
3. **Resolve Path:**
    * Locate the target Task directory: `docs/control/05-tasks/02-reports/{Task ID}/`.
    * Construct filename: `{Sequence ID}-{Role}.md` (e.g., `PLAN-01-engineer.md`).
    * *Note:* Plans are stored alongside Reports to keep the full execution history together.
4. **Write to Disk:** Save the content as a new file.
5. **Git Operations:** Automatically stage (`git add`) the new plan.
